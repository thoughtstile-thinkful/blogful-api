# Explainer for Blogful-API

## What are we trying to do?

This is an Express server.  
Consider this the 'controller' of data.

It achieves persistent changes to data via a Postgres database.

Without the Postgres database, there cannot be any persistent changes.  
After the Express server shuts down, all changes are lost.

The same can be said for clients (end-users).  
Clients cannot directly make changes to the database.  
The request must be routed through the Express server.

This server should have total CRUD (create, read, update, destroy) capabilities when completed.  
It should also have robust testing to ensure that the original data does not become compromised.

Structure for this is split into sections based on Folders.

---

## `./src/` - Two Levels of API

### Files

`./src/app.js`  
`./src/articles-service.js`  
`./src/config.js`  
`./src/server.js`

### Requirements

---

Let's first take a look at: `./src/app.js`.

Requests to the server are routed here.  
It's where the actual API is defined.

So if we wanted to `GET` some articles, it's written here as:

```javascript
// app.js
app.get('/articles', (req, res, next) => {
  const knexInstance = req.app.get('db');
  ArticlesService.getAllArticles(knexInstance)
    .then(articles => {
      res.json(articles);
    })
    .catch(next);
});
```

Okay so, what is `knex`? Why are our API requests being routed through it?

Here's the thing.

The Postgres database used here requires `.sql` commands to make changes to it.

`Knex` is a library that lets you write these `.sql` commands in javascript instead.

`Knex` acts as a bridge between the two languages. But even though we're writing in javascript, the syntax must still be formatted as `.sql` instructions.

These instructions are in `articles-service.js`.  
This is what the `INSERT` function looks like:

```javascript
  // articles-service.js
  insertArticle(knex, newArticle) {
    return knex
      .insert(newArticle)
      .into('blogful_articles')
      .returning('*')
      .then(rows => {
        return rows[0];
      });
  },
```

Not very javascripty.  
Consider `articles-service.js` as the second level of API.  
We route requests to `app.js` using the functions we created in `articles-service.js`.

---

#### Pivot Point

Okay, so that was all of `./src`.

Seems simple enough.

So what's all the other stuff for?

Well, Servers and Databases make _permanent_ changes.

Also, Databases work at scale, which magnifies any mistakes made, and makes debugging much more difficult (and potentially catastrophic).

Due to this nature, extensive testing is needed to make sure everything is working properly. Testing of multiple kinds, which are included here.

## `./migrations/` - Version Control for Tables

### Requirements

---

Let's look at the top folder `migrations`.  
There are actual `.sql` files here - so they're making changes to the Postgres database.

Inside, we'll see files like:  
`001.do.create_blogful_articles.sql`, and `001.undo.create_blogful_articles.sql`.

These files exist in relation to each other.  
One file creates changes, and the other undos them.

So what does the code look like?

```sql
-- 001.do.create_blogful_articles.sql
CREATE TABLE blogful_articles (
  id INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
  title TEXT NOT NULL,
  content TEXT,
  date_published TIMESTAMP DEFAULT NOW() NOT NULL
);
```

```sql
-- 001.undo.create_blogful_articles.sql
DROP TABLE IF EXISTS blogful_articles;
```

New syntax.  
Here we have CREATE TABLE.  
To explain this code, let's first do a quick primer on how Postgres works.

#### Primer on Postgres

A DATABASE is comprised of multiple TABLES.  
TABLES are comprised of multiple COLUMNS.  
Each COLUMN has a label.  
Examples labels can be: id, name, date published, etc.  
It's very similar to an excel spreadsheet in structure.

---

Let's go back to `001.do.create_blogful_articles.sql`.

Okay, so this creates a TABLE called blogful_articles, in a DATABASE (assigned beforehand).
This TABLE has 4 COLUMNS called id, title, content, and date_published.

And `001.undo.create_blogful_articles.sql` drops this TABLE and destroys it.

The 002 series of commands works the same way.

So these commands are REVERSIBLE. Like git. But perhaps even better.

With commands like:

```
npm run migrate -- 0
```

We can revert the TABLE to its original state.

And we can use commands like:

```
npm run migrate
```

To bring the TABLE to it's most updated state.

---

#### ./src

1. app.js
2. articles-service.js
3. config.js
4. server.js

---

#### Notes:

- Mention the database setup
- clearer intro
- server vs Express server, be definitive with terms when not cumbersome
- make it clearer that articles is for this case, not in a general case
- make explaining the parameters of the examples and syntax part of the explanation. (if you don't do this someone with no familiarity will have trouble parsing it)
- abstraction is in the wrong order right now (start from .sql -> articles-service.js -> app.js)
- HQ: you 'require' knex and 'app' in server.js, but how does app.js import knex library commands when it doesnt ever import them?
- HQ: How does the error handling app.use work?
